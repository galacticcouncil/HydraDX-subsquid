type Token @entity {
  id: ID!
  decimal: Int!
  name: String!
  shared: Boolean!
  parentPool: Pool
}

type Account @entity {
  id: ID!
  specVersion: Int
  createdPools: [Pool] @derivedFrom(field: "ownerAccount")

  tradeTransferOut: [TradeTransfer] @derivedFrom(field: "accountSent")
  tradeTransferIn: [TradeTransfer] @derivedFrom(field: "accountReceived")
  initiatedSwapActions: [SwapAction] @derivedFrom(field: "initiatedByAccount")
}

type Pool @entity {
  id: ID!
  specVersion: String
  isActive: Boolean!
  sharedToken: Token
  sharedAssetInitialBalance: BigInt
  ownerAccount: Account
  createdAt: DateTime!
  deletedAt: DateTime!
  tokenZero: Token!
  tokenOne: Token!
  swapActions: [SwapAction] @derivedFrom(field: "xykTradePool")
  assetsVolume: [PoolAssetVolume] @derivedFrom(field: "pool")
}

#  id: string | null;
#+  slippage?: BigNumber;
#+  fees?: DirectTradeFee[];
#+  totalFeeFinal?: BigNumber;
#+  match?: BigNumber;
#+  totalDirectTradeExchanged?: BigNumber;
#+  saved?: BigNumber;
#+ intentionType?: string;
#+  account?: string;
#+  asset1?: string;
#+  asset2?: string;
#+  amount?: BigNumber;
#+  amountXykTrade?: BigNumber;
#+  amountOutXykTrade?: BigNumber;
#+  amountSoldBought?: BigNumber;
#+  totalAmountFinal?: BigNumber;
#  errorDetails?: string | { section: string; name: string; documentation: string };
#+  assetsPair?: string;
#  directTrades?: {
#  amountSent: BigNumber;
#  amountReceived: BigNumber;
#  account1: string;
#  account2: string;
#  pairedIntention: string;
#  }[];

type DirectTradeFee @jsonField {
  accountIdWho: String!
  accountIdTo: String!
  assetId: String!
  amount: String!
}

type SwapActionFees @jsonField {
  directTrade: [DirectTradeFee]
}

type SwapEventMeta @jsonField {
  section: String!
  method: String!
  dispatchInfo: String!
}

type SwapActionErrorDetails @jsonField {
  section: String
  name: String
  documantation: String
}

type SwapActionMetadata @jsonField {
  statusReady: Boolean
  statusInBlock: Boolean
  statusFinalized: Boolean
  statusError: Boolean
  errorsDetails: [SwapActionErrorDetails]
  eventsMeta: [SwapEventMeta]
}

type SwapAction @entity {
  id: ID!
  timestamp: DateTime!
  block: String!
  initiatedByAccount: Account!

  intentionType: String!
  amount: BigInt
  tokenZero: Token
  tokenOne: Token
  assetsPair: String

  slippage: BigInt
  fees: SwapActionFees!
  totalFeeFinal: BigInt
  match: BigInt
  totalDirectTradeExchanged: BigInt
  saved: BigInt
  amountXykTrade: BigInt
  amountOutXykTrade: BigInt
  amountSoldBought: BigInt
  totalAmountFinal: BigInt
  xykTradePool: Pool

  actionMetadata: SwapActionMetadata

  directTrades: [TradeTransfer] @derivedFrom(field: "parentSwapAction")
}

type TradeTransfer @entity {
  id: ID!
  timestamp: DateTime!
  block: String!
  #  pairedIntention >>>
  parentSwapAction: SwapAction!

  assetSent: Token!
  assetReceived: Token!
  accountSent: Account!
  accountReceived: Account!
  amountSent: BigInt
  amountReceived: BigInt
}

#type SwapAction @entity {
#  id: ID!
#  isSuccess: Int!
#  timestamp: BigInt!
#  block: String!
#  type: String!
#
#  tokenZero: Token
#  tokenOne: Token
#
#  account: Account
#
#  directTrades: [TradeTransfer] @derivedFrom(field: "swapAction")
#  xykTradePool: Pool
#}

#type TradeTransfer @entity {
#  id: ID!
#  isSuccess: Int!
#  timestamp: BigInt!
#  block: String!
#  swapAction: SwapAction!
#
#  accountTo: Account!
#  accountFrom: Account!
#
#  type: String!
#  path: String!
#  tokenZero: String!
#  tokenOne: String!
#  tokenZeroInput: String!
#  tokenOneInput: String!
#  result: String!
#}

type PoolAssetVolume @entity {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  tokenZeroAmount: BigInt
  tokenOneAmount: BigInt
  sharedAssetAmount: BigInt
  marketCap: BigInt
  tradeAmount: BigInt
}

type AssetPrice @entity {
  id: ID!
  tokenZero: Token
  tokenOne: Token
  pairName: String!
  prices: AssetPriceInTime
}

type AssetPriceInTime @entity {
  id: ID!
  timestamp: BigInt!
  price: BigInt
}

# ----- Staking rewards -----

type SumReward @entity {
  id: ID! # AccountId
  accountReward: BigInt!

  accountSlash: BigInt!

  accountTotal: BigInt!
}

# in early stage of kusama, some validators didn't need to bond to start staking
type NoBondRecordAccount @entity {
  id: ID! # AccountId
  firstRewardAt: Int!
}

type StakingReward @entity {
  id: ID!
  address: String!
  balance: BigInt!
  date: DateTime!
}

type StakingSlash @entity {
  id: ID! # AccountId
  address: String!
  balance: BigInt!
  date: DateTime!
}
