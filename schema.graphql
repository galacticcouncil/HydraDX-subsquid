type Token @entity {
  id: ID!
  decimal: Int!
  name: String!
  shared: Boolean!
  parentPool: Pool
}

type Account @entity {
  id: ID!
  specVersion: Int
  createdPools: [Pool] @derivedFrom(field: "ownerAccount")

  tradeTransferOut: [TradeTransfer] @derivedFrom(field: "accountSent")
  tradeTransferIn: [TradeTransfer] @derivedFrom(field: "accountReceived")
}

type Pool @entity {
  id: ID!
  specVersion: String
  isActive: Boolean!
  sharedToken: Token
  sharedAssetInitialBalance: BigInt
  ownerAccount: Account
  createdAt: DateTime!
  deletedAt: DateTime!
  tokenZero: Token!
  tokenOne: Token!
  swapActions: [SwapAction] @derivedFrom(field: "xykTradePool")
  assetsVolume: [PoolAssetVolume] @derivedFrom(field: "pool")
}


#  id: string | null;
#+  slippage?: BigNumber;
#+  fees?: DirectTradeFee[];
#+  totalFeeFinal?: BigNumber;
#+  match?: BigNumber;
#+  totalDirectTradeExchanged?: BigNumber;
#+  saved?: BigNumber;
#+ intentionType?: string;
#+  account?: string;
#+  asset1?: string;
#+  asset2?: string;
#+  amount?: BigNumber;
#+  amountXykTrade?: BigNumber;
#+  amountOutXykTrade?: BigNumber;
#+  amountSoldBought?: BigNumber;
#+  totalAmountFinal?: BigNumber;
#  errorDetails?: string | { section: string; name: string; documentation: string };
#+  assetsPair?: string;
#  directTrades?: {
  #  amountSent: BigNumber;
  #  amountReceived: BigNumber;
  #  account1: string;
  #  account2: string;
  #  pairedIntention: string;
#  }[];

type DirectTradeFee @jsonField {
  account1: String
  account2: String
  asset: String
  amount: BigInt
}

type SwapAction @entity {
  id: ID!
  timestamp: BigInt!
  block: String!

  intentionType: String!
  slippage: BigInt
  fees: [DirectTradeFee]
  totalFeeFinal: BigInt
  match: BigInt
  totalDirectTradeExchanged: BigInt
  saved: BigInt
  account: Account

  tokenZero: Token
  tokenOne: Token
  amount: BigInt
  amountXykTrade: BigInt
  amountOutXykTrade: BigInt
  amountSoldBought: BigInt
  totalAmountFinal: BigInt
  assetsPair: String
  xykTradePool: Pool

  directTrades: [TradeTransfer] @derivedFrom(field: "swapAction")
}

type TradeTransfer @entity {
  id: ID!
  timestamp: BigInt!
  block: String!
  #  pairedIntention >>>
  swapAction: SwapAction!

  accountReceived: Account!
  accountSent: Account!

  amountReceived: BigInt
  amountSent: BigInt
}

#type SwapAction @entity {
#  id: ID!
#  isSuccess: Int!
#  timestamp: BigInt!
#  block: String!
#  type: String!
#
#  tokenZero: Token
#  tokenOne: Token
#
#  account: Account
#
#  directTrades: [TradeTransfer] @derivedFrom(field: "swapAction")
#  xykTradePool: Pool
#}

#type TradeTransfer @entity {
#  id: ID!
#  isSuccess: Int!
#  timestamp: BigInt!
#  block: String!
#  swapAction: SwapAction!
#
#  accountTo: Account!
#  accountFrom: Account!
#
#  type: String!
#  path: String!
#  tokenZero: String!
#  tokenOne: String!
#  tokenZeroInput: String!
#  tokenOneInput: String!
#  result: String!
#}


type PoolAssetVolume @entity {
  id: ID!
  pool: Pool!
  timestamp: BigInt!
  tokenZeroAmount: BigInt
  tokenOneAmount: BigInt
  sharedAssetAmount: BigInt
  marketCap: BigInt
  tradeAmount: BigInt
}

type AssetPrice @entity {
  id: ID!
  tokenZero: Token
  tokenOne: Token
  pairName: String!
  prices: AssetPriceInTime
}

type AssetPriceInTime @entity {
  id: ID!
  timestamp: BigInt!
  price: BigInt
}

# ----- Staking rewards -----

type SumReward @entity{

  id: ID! # AccountId

  accountReward: BigInt!

  accountSlash: BigInt!

  accountTotal: BigInt!
}

# in early stage of kusama, some validators didn't need to bond to start staking
type NoBondRecordAccount @entity {
  id: ID! # AccountId

  firstRewardAt: Int!
}


type StakingReward @entity{
  id: ID!
  address: String!
  balance: BigInt!
  date: DateTime!
}


type StakingSlash @entity{
  id: ID! # AccountId
  address: String!
  balance: BigInt!
  date: DateTime!
}
